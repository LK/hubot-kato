// Generated by CoffeeScript 1.7.1
(function() {
  var Adapter, EnterMessage, EventEmitter, HTTP, HTTPS, Kato, KatoClient, LeaveMessage, Response, Robot, TextMessage, WebSocketClient, _ref,
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    __slice = [].slice;

  HTTP = require('http');

  HTTPS = require('https');

  EventEmitter = require('events').EventEmitter;

  WebSocketClient = require('websocket').client;

  _ref = require('hubot'), Robot = _ref.Robot, Adapter = _ref.Adapter, TextMessage = _ref.TextMessage, EnterMessage = _ref.EnterMessage, LeaveMessage = _ref.LeaveMessage, Response = _ref.Response;

  try {
    TextMessage = require('../../../src/message').TextMessage;
  } catch (_error) {}

  Kato = (function(_super) {
    __extends(Kato, _super);

    function Kato(robot) {
      Kato.__super__.constructor.call(this, robot);
      this.logger = robot.logger;
    }

    Kato.prototype.send = function() {
      var envelope, str, strings, _i, _len, _results;
      envelope = arguments[0], strings = 2 <= arguments.length ? __slice.call(arguments, 1) : [];
      _results = [];
      for (_i = 0, _len = strings.length; _i < _len; _i++) {
        str = strings[_i];
        _results.push(this.client.send(envelope.room, str));
      }
      return _results;
    };

    Kato.prototype.reply = function() {
      var envelope, strings;
      envelope = arguments[0], strings = 2 <= arguments.length ? __slice.call(arguments, 1) : [];
      strings = strings.map(function(s) {
        return "" + envelope.user.name + ": " + s;
      });
      return this.send.apply(this, [envelope.user].concat(__slice.call(strings)));
    };

    Kato.prototype.run = function() {
      var client, options, self;
      self = this;
      options = {
        api_url: process.env.HUBOT_KATO_API || "https://api.kato.im",
        login: process.env.HUBOT_KATO_LOGIN,
        password: process.env.HUBOT_KATO_PASSWORD,
        rooms: process.env.HUBOT_KATO_ROOMS
      };
      if (options.rooms) {
        options.rooms = options.rooms.split(",");
      }
      this.logger.debug("Kato adapter options: " + (JSON.stringify(options)));
      if (!((options.login != null) && (options.password != null) && (options.rooms != null))) {
        this.robot.logger.error("Not enough parameters provided. I need a login, password and rooms");
        process.exit(1);
      }
      client = new KatoClient(options, this.robot);
      client.on("TextMessage", function(user, message) {
        if (user.id !== client.account_id) {
          return self.receive(new TextMessage(user, message));
        }
      });
      client.on('reconnect', function() {
        return setTimeout(function() {
          return client.Login();
        }, 5000);
      });
      client.Login();
      this.client = client;
      return self.emit("connected");
    };

    return Kato;

  })(Adapter);

  exports.use = function(robot) {
    return new Kato(robot);
  };

  KatoClient = (function(_super) {
    var self;

    __extends(KatoClient, _super);

    self = KatoClient;

    function KatoClient(options, robot) {
      var host, schema, _ref1;
      this.robot = robot;
      self = this;
      _ref1 = options.api_url.split("://"), schema = _ref1[0], host = _ref1[1];
      self.secure = schema === "https";
      self.api_host = host;
      self.login = options.login;
      self.password = options.password;
      self.rooms = options.rooms;
      this.on('login', function(err) {
        return this.WebSocket();
      });
    }

    KatoClient.prototype.Login = function() {
      var data, id, logger;
      logger = this.robot.logger;
      id = this.uuid();
      data = JSON.stringify({
        email: self.login,
        password: self.password
      });
      return this.put("/sessions/" + id, data, function(err, data) {
        var body, json, response;
        response = data.response, body = data.body;
        switch (response.statusCode) {
          case 200:
            self.sessionKey = response.headers['set-cookie'][0].split(';')[0];
            self.sessionId = id;
            json = JSON.parse(body);
            self.account_id = json.account_id;
            self.session_id = json.id;
            return self.emit('login');
          case 403:
            logger.error("Invalid login/password combination");
            return process.exit(2);
          default:
            logger.error("Can't login. Status: " + response.statusCode + ", Id: " + id + ", Headers: " + (JSON.stringify(response.headers)));
            logger.error("Kato error: " + response.statusCode);
            return self.emit('reconnect');
        }
      });
    };

    KatoClient.prototype.WebSocket = function() {
      var client, headers, logger;
      logger = this.robot.logger;
      client = new WebSocketClient();
      client.on('connectFailed', function(error) {
        return console.log('Connect Error: ' + error.toString());
      });
      client.on('connect', function(connection) {
        var room_id, _i, _len, _ref1, _results;
        self.connection = connection;
        connection.on('close', function() {
          console.log('echo-protocol Connection Closed');
          return self.emit('reconnect');
        });
        connection.on('error', function(error) {
          return console.log('error', error);
        });
        connection.on('message', function(message) {
          var data, user;
          if (message.type === 'utf8') {
            data = JSON.parse(message.utf8Data);
            if (data.type === "text") {
              user = {
                id: data.from.id,
                name: data.from.name,
                room: data.room_id
              };
              user = self.robot.brain.userForId(user.id, user);
              return self.emit("TextMessage", user, data.params.text);
            } else if (data.type === "read" || data.type === "typing" || data.type === "silence") {

            } else {
              return console.log("Received: '", data, "'");
            }
          }
        });
        _ref1 = self.rooms;
        _results = [];
        for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
          room_id = _ref1[_i];
          logger.info("Joining " + room_id);
          _results.push(connection.sendUTF(JSON.stringify({
            room_id: room_id,
            type: "hello"
          })));
        }
        return _results;
      });
      headers = {
        'Cookie': self.sessionKey
      };
      return client.connect((self.secure ? 'wss' : 'ws') + '://' + self.api_host + '/ws', null, null, headers);
    };

    KatoClient.prototype.uuid = function(size) {
      var part;
      part = function(d) {
        if (d) {
          return part(d - 1) + Math.ceil(0xffffffff * Math.random()).toString(16);
        } else {
          return '';
        }
      };
      return part(size || 8);
    };

    KatoClient.prototype.send = function(room_id, str) {
      return this.connection.sendUTF(JSON.stringify({
        room_id: room_id,
        type: "text",
        params: {
          text: str
        }
      }));
    };

    KatoClient.prototype.put = function(path, body, callback) {
      return this.request("PUT", path, body, callback);
    };

    KatoClient.prototype.request = function(method, path, body, callback) {
      var headers, logger, module, options, port, request;
      logger = this.robot.logger;
      if (self.secure) {
        module = HTTPS;
        port = 443;
      } else {
        module = HTTP;
        port = 80;
      }
      headers = {
        "Authorization": this.authorization,
        "Host": self.api_host,
        "Content-Type": "application/json"
      };
      options = {
        "agent": false,
        "host": self.api_host,
        "port": port,
        "path": path,
        "method": method,
        "headers": headers
      };
      if (method === "POST" || method === "PUT") {
        if (typeof body !== "string") {
          body = JSON.stringify(body);
        }
        body = new Buffer(body);
        options.headers["Content-Length"] = body.length;
      }
      request = module.request(options, function(response) {
        var data;
        data = "";
        response.on("data", function(chunk) {
          return data += chunk;
        });
        response.on("end", function() {
          return callback(null, {
            response: response,
            body: data
          });
        });
        return response.on("error", function(err) {
          logger.error("Kato response error: " + err);
          return callback(err, {});
        });
      });
      if (method === "POST" || method === "PUT") {
        request.end(body, 'binary');
      } else {
        request.end();
      }
      return request.on("error", function(err) {
        return logger.error("Kato request error: " + err);
      });
    };

    return KatoClient;

  })(EventEmitter);

}).call(this);
